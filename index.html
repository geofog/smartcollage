<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Smart Collage (Final V11 - Sorted Match)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <style>
        .no-scrollbar::-webkit-scrollbar { display: none; }
        .no-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
        body { 
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
            background-color: #ffffff;
            touch-action: none;
        }
        /* ÌÉÄÏùº ÏõÄÏßÅÏûÑ Ïï†ÎãàÎ©îÏù¥ÏÖò */
        .tile-transition {
            transition: all 0.5s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        /* ÏÑ†ÌÉù Ìö®Í≥º */
        @keyframes pulse-select {
            0% { box-shadow: 0 0 0 0 rgba(79, 70, 229, 0.4); }
            70% { box-shadow: 0 0 0 10px rgba(79, 70, 229, 0); }
            100% { box-shadow: 0 0 0 0 rgba(79, 70, 229, 0); }
        }
        .selected-tile {
            z-index: 50 !important;
            animation: pulse-select 1.5s infinite;
            border: 2px solid #4f46e5;
        }
        .evolution-active {
            border: 2px solid rgba(99, 102, 241, 0.5);
        }
        /* Ìä∏Î¶¨ ÎùºÏù∏ Ïï†ÎãàÎ©îÏù¥ÏÖò */
        @keyframes dash {
            to { stroke-dashoffset: -20; }
        }
        .tree-line {
            animation: dash 30s linear infinite;
        }
        /* Ïä¨ÎùºÏù¥Îçî Ïä§ÌÉÄÏùº */
        input[type=range] {
            -webkit-appearance: none;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #4f46e5;
            cursor: pointer;
            margin-top: -6px;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #e5e7eb;
            border-radius: 2px;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden flex flex-col bg-white">
    <div id="root" class="h-full w-full"></div>

    <script>
        window.onerror = function(msg, url, lineNo, columnNo, error) {
            console.error(msg);
            return false;
        };
    </script>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // --- Icons ---
        const IconMonitor = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect width="20" height="14" x="2" y="3" rx="2"/><line x1="8" x2="16" y1="21" y2="21"/><line x1="12" x2="12" y1="17" y2="21"/></svg>;
        const IconUpload = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" x2="12" y1="3" y2="15"/></svg>;
        const IconDownload = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" x2="12" y1="15" y2="3"/></svg>;
        const IconRefresh = ({size=24, className=""}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className}><path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/><path d="M21 3v5h-5"/><path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/><path d="M8 16H3v5"/></svg>;
        const IconX = ({size=14}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        const IconHand = ({size=24}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M18 11V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v0"/><path d="M14 10V4a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v2"/><path d="M10 10.5V6a2 2 0 0 0-2-2v0a2 2 0 0 0-2 2v8"/><path d="M18 8a2 2 0 1 1 4 0v6a8 8 0 0 1-8 8h-2c-2.8 0-4.5-.86-5.99-2.34l-3.6-3.6a2 2 0 0 1 2.83-2.82L7 15"/></svg>;
        const IconZoomIn = ({size=20}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="11" x2="11" y1="8" y2="14"/><line x1="8" x2="14" y1="11" y2="11"/></svg>;
        const IconZoomOut = ({size=20}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="11" cy="11" r="8"/><line x1="21" x2="16.65" y1="21" y2="16.65"/><line x1="8" x2="14" y1="11" y2="11"/></svg>;
        const IconScissors = ({size=14}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="6" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><line x1="20" x2="8.12" y1="4" y2="15.88"/><line x1="14.47" x2="20" y1="14.48" y2="20"/><line x1="8.12" x2="12" y1="8.12" y2="12"/></svg>;
        const IconTree = ({size=20}) => <svg xmlns="http://www.w3.org/2000/svg" width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="5" r="2"/><circle cx="5" cy="19" r="2"/><circle cx="19" cy="19" r="2"/><path d="M12 7v7"/><path d="M12 14 5 17"/><path d="M12 14l7 3"/></svg>;

        // --- Constants ---
        const PAPER_SIZES = {
            A4: { name: 'A4 (21x29.7cm)', width: 7016, height: 4960, ratio: 1.414 }, 
            P_4X6: { name: '4x6" (10x15cm)', width: 3600, height: 2400, ratio: 1.5 },
            P_5X7: { name: '5x7" (13x18cm)', width: 4200, height: 3000, ratio: 1.4 },
            P_8X10: { name: '8x10" (20x25cm)', width: 6000, height: 4800, ratio: 1.25 },
            P_11X14: { name: '11x14" (28x36cm)', width: 8400, height: 6600, ratio: 1.27 },
            SQ_12: { name: '12x12" (30x30cm)', width: 7200, height: 7200, ratio: 1.0 },
            HD_16_9: { name: '16:9 Screen', width: 1920, height: 1080, ratio: 1.77 },
        };
        const DPI_OPTIONS = [300, 400, 500, 600];
        const MAX_ITERATIONS = 200; // Increased for better results

        // --- Helpers ---
        const loadImageMeta = (file) => {
            return new Promise((resolve) => {
                const url = URL.createObjectURL(file);
                const img = new window.Image();
                img.onload = () => {
                    resolve({
                        id: Math.random().toString(36).substr(2, 9),
                        url,
                        file,
                        width: img.naturalWidth,
                        height: img.naturalHeight,
                        aspect: img.naturalWidth / img.naturalHeight,
                        offsetX: 0.5,
                        offsetY: 0.5
                    });
                };
                img.src = url;
            });
        };

        const formatDate = () => {
            const now = new Date();
            const yyyy = now.getFullYear();
            const mm = String(now.getMonth() + 1).padStart(2, '0');
            const dd = String(now.getDate()).padStart(2, '0');
            const hh = String(now.getHours()).padStart(2, '0');
            const min = String(now.getMinutes()).padStart(2, '0');
            const ss = String(now.getSeconds()).padStart(2, '0');
            return `${yyyy}${mm}${dd}-${hh}${min}${ss}`;
        };

        // --- Node Structure ---
        const createNode = (x, y, w, h) => ({
            type: 'node', split: 'v', ratio: 0.5, x, y, w, h, parent: null, left: null, right: null, isLeft: false, imageId: null
        });

        const createLeaf = (x, y, w, h) => ({
            type: 'leaf', x, y, w, h, imageId: null, parent: null, isLeft: false
        });

        // --- 1. Skeleton Builder (Random Split N >= 3) ---
        const buildSkeletonTree = (x, y, w, h, count) => {
            if (count === 1) return createLeaf(x, y, w, h);

            const node = createNode(x, y, w, h);
            const aspect = w / h;
            node.split = aspect >= 1.0 ? 'vertical' : 'horizontal';
            
            if (count >= 3) node.ratio = 0.3 + (Math.random() * 0.4); 
            else node.ratio = 0.5;

            const countA = Math.floor(count / 2);
            const countB = count - countA;

            let wA, hA, wB, hB, xB, yB;
            if (node.split === 'vertical') {
                wA = w * node.ratio; hA = h;
                wB = w - wA;         hB = h;
                xB = x + wA;         yB = y;
            } else {
                wA = w;              hA = h * node.ratio;
                wB = w;              hB = h - hA;
                xB = x;              yB = y + hA;
            }

            node.left = buildSkeletonTree(x, y, wA, hA, countA);
            node.left.parent = node; node.left.isLeft = true;

            node.right = buildSkeletonTree(xB, yB, wB, hB, countB);
            node.right.parent = node; node.right.isLeft = false;

            return node;
        };

        const getLeavesInOrder = (node, list = []) => {
            if (node.type === 'leaf') list.push(node);
            else { getLeavesInOrder(node.left, list); getLeavesInOrder(node.right, list); }
            return list;
        };

        const findNodeByImageId = (node, id) => {
            if (!node) return null;
            if (node.type === 'leaf' && node.imageId === id) return node;
            return findNodeByImageId(node.left, id) || findNodeByImageId(node.right, id);
        };

        // --- 2. Adaptive Fill Algorithm (V11 - Sorted Matching) ---
        const calculateAdaptiveLayout = (imageIds, imagesMap, containerW, containerH) => {
            if (imageIds.length === 0) return { rects: [], root: null };
            if (imageIds.length === 1) return { rects: [{ imageId: imageIds[0], x: 0, y: 0, w: containerW, h: containerH }], root: null };

            // 1. Build Skeleton
            const root = buildSkeletonTree(0, 0, containerW, containerH, imageIds.length);
            
            // 2. Smart Assignment Logic
            const leaves = getLeavesInOrder(root);
            
            // üí° SORTED MATCHING: 
            // Í∞ÄÎ°ú Ïπ∏ÏùÄ 'Îçî' Í∞ÄÎ°úÎ°ú Í∏¥ ÏàúÏÑúÎ°ú Ï†ïÎ†¨
            const landLeaves = leaves.filter(l => (l.w / l.h) >= 1.0).sort((a, b) => (a.w/a.h) - (b.w/b.h));
            // ÏÑ∏Î°ú Ïπ∏ÏùÄ 'Îçî' ÏÑ∏Î°úÎ°ú Í∏¥ ÏàúÏÑúÎ°ú Ï†ïÎ†¨ (ÎπÑÏú®Ïù¥ ÏûëÏùÄ ÏàúÏÑú)
            const portLeaves = leaves.filter(l => (l.w / l.h) < 1.0).sort((a, b) => (a.w/a.h) - (b.w/b.h));

            // Ïù¥ÎØ∏ÏßÄ Î∂ÑÎ•ò
            const landImgIds = [];
            const portImgIds = [];
            imageIds.forEach(id => {
                const img = imagesMap.get(id);
                if (img.aspect >= 1.0) landImgIds.push(id);
                else portImgIds.push(id);
            });

            // üí° Ïù¥ÎØ∏ÏßÄÎèÑ ÎπÑÏú® ÏàúÏÑúÎ°ú Ï†ïÎ†¨ (ÎÅºÎ¶¨ÎÅºÎ¶¨ Îß§Ïπ≠ÏùÑ ÏúÑÌï¥)
            // Í∞ÄÎ°ú Ïù¥ÎØ∏ÏßÄÎäî ÎπÑÏú®Ïù¥ ÏûëÏùÄ Í≤É -> ÌÅ∞ Í≤É ÏàúÏúºÎ°ú Ï†ïÎ†¨ (pop() Ìï† Îïå ÌÅ∞ Í≤ÉÏù¥ ÎÇòÏò¥)
            landImgIds.sort((a, b) => imagesMap.get(a).aspect - imagesMap.get(b).aspect);
            // ÏÑ∏Î°ú Ïù¥ÎØ∏ÏßÄÎäî ÎπÑÏú®Ïù¥ ÏûëÏùÄ Í≤É -> ÌÅ∞ Í≤É ÏàúÏúºÎ°ú Ï†ïÎ†¨
            portImgIds.sort((a, b) => imagesMap.get(a).aspect - imagesMap.get(b).aspect);

            const fillSlots = (slots, ids) => {
                // Îí§ÏóêÏÑúÎ∂ÄÌÑ∞ Í∫ºÎÇ¥ÏÑú Îß§Ïπ≠ (Í∞ÄÏû• ÎπÑÏú®Ïù¥ ÌÅ∞ ÎÜà <-> Í∞ÄÏû• ÎπÑÏú®Ïù¥ ÌÅ∞ ÎÜà)
                while (slots.length > 0 && ids.length > 0) {
                    const leaf = slots.pop();
                    const id = ids.pop();
                    leaf.imageId = id;
                }
            };

            // Priority Fill: Match Orientation
            fillSlots(landLeaves, landImgIds);
            fillSlots(portLeaves, portImgIds);

            // Fallback Fill: Cross Match
            // ÎÇ®ÏùÄ Í≤ÉÎì§ÎÅºÎ¶¨ Îã§Ïãú Î™®ÏïÑÏÑú Ï†ïÎ†¨ ÌõÑ Îß§Ïπ≠ (Ïù¥ Î∂ÄÎ∂ÑÏùÄ ÎûúÎç§ÏÑ±Î≥¥Îã§ Ìö®Ïú®ÏÑ± Ï§ëÏãú)
            const remainingLeaves = [...landLeaves, ...portLeaves];
            const remainingIds = [...landImgIds, ...portImgIds];
            
            // ÎÇ®ÏùÄ Í≤ÉÎì§ÏùÄ Í∑∏ÎÉ• ÏàúÏÑúÎåÄÎ°ú ÎÑ£Ïùå (Ïù¥ÎØ∏ ÏßùÏù¥ Ïïà ÎßûÎäî ÏÉÅÌô©)
            while (remainingLeaves.length > 0 && remainingIds.length > 0) {
                remainingLeaves.pop().imageId = remainingIds.pop();
            }
            
            // 3. Mutate (Skip if 2 images)
            if (imageIds.length !== 2) {
                refineTree(root, imagesMap);
            }

            // 4. Flatten
            const rects = flattenTree(root, 0, 0, containerW, containerH, imagesMap);
            return { rects, root };
        };

        const refineTree = (root, imagesMap) => {
            const leaves = getLeavesInOrder(root);
            const reverseLeaves = [...leaves].reverse();

            reverseLeaves.forEach(leaf => {
                if (!leaf.imageId) return;
                const img = imagesMap.get(leaf.imageId);
                
                if (leaf.parent) {
                    const parent = leaf.parent;
                    let targetImgAspect = img.aspect;
                    // Clamp aspect to avoid extreme distortion
                    if (targetImgAspect >= 1.0) targetImgAspect = Math.max(1.33, Math.min(1.5, targetImgAspect));
                    else targetImgAspect = Math.max(0.66, Math.min(0.75, targetImgAspect));

                    let newParentRatio = parent.ratio;
                    if (parent.split === 'vertical') {
                        if (leaf.isLeft) {
                            const targetW = leaf.h * targetImgAspect;
                            newParentRatio = targetW / parent.w;
                        } else {
                            const targetW = leaf.h * targetImgAspect;
                            newParentRatio = 1 - (targetW / parent.w);
                        }
                    } else {
                        if (leaf.isLeft) { 
                             const targetH = leaf.w / targetImgAspect;
                             newParentRatio = targetH / parent.h;
                        } else { 
                             const targetH = leaf.w / targetImgAspect;
                             newParentRatio = 1 - (targetH / parent.h);
                        }
                    }
                    const blendedRatio = (parent.ratio * 0.3) + (newParentRatio * 0.7);
                    parent.ratio = Math.max(0.2, Math.min(0.8, blendedRatio));
                }
            });
        };

        const flattenTree = (node, cx, cy, cw, ch, imagesMap) => {
            node.x = cx; node.y = cy; node.w = cw; node.h = ch;
            if (node.type === 'leaf') {
                const finalAspect = cw / ch;
                const img = imagesMap.get(node.imageId);
                // isSacrificed check
                return [{ imageId: node.imageId, x: cx, y: cy, w: cw, h: ch }];
            }
            let w1, h1, x2, y2, w2, h2;
            if (node.split === 'vertical') {
                w1 = cw * node.ratio; h1 = ch; w2 = cw - w1; h2 = ch; x2 = cx + w1; y2 = cy;
            } else {
                w1 = cw; h1 = ch * node.ratio; w2 = cw; h2 = ch - h1; x2 = cx; y2 = cy + h1;
            }
            return [...flattenTree(node.left, cx, cy, w1, h1, imagesMap), ...flattenTree(node.right, x2, y2, w2, h2, imagesMap)];
        };

        const TreeOverlay = ({ node, totalW, totalH }) => {
            if (!node) return null;
            const renderLines = (n) => {
                if (!n || n.type === 'leaf') return null;
                const cx = n.x + n.w / 2; const cy = n.y + n.h / 2;
                const cxPct = (cx / totalW) * 100 + '%'; const cyPct = (cy / totalH) * 100 + '%';
                const lines = [];
                if (n.left) {
                    const lcx = n.left.x + n.left.w / 2; const lcy = n.left.y + n.left.h / 2;
                    lines.push(<line key={`l-${n.x}-${n.y}`} x1={cxPct} y1={cyPct} x2={(lcx/totalW)*100+'%'} y2={(lcy/totalH)*100+'%'} stroke="#f43f5e" strokeWidth="2" strokeDasharray="4 4" className="tree-line" />);
                    lines.push(renderLines(n.left));
                }
                if (n.right) {
                    const rcx = n.right.x + n.right.w / 2; const rcy = n.right.y + n.right.h / 2;
                    lines.push(<line key={`r-${n.x}-${n.y}`} x1={cxPct} y1={cyPct} x2={(rcx/totalW)*100+'%'} y2={(rcy/totalH)*100+'%'} stroke="#f43f5e" strokeWidth="2" strokeDasharray="4 4" className="tree-line" />);
                    lines.push(renderLines(n.right));
                }
                lines.push(<circle key={`c-${n.x}-${n.y}`} cx={cxPct} cy={cyPct} r="3" fill="#f43f5e" stroke="white" strokeWidth="1" />);
                return lines;
            };
            return <svg className="absolute inset-0 w-full h-full pointer-events-none z-20 overflow-visible filter drop-shadow-md">{renderLines(node)}</svg>;
        };

        // --- Main App ---
        function App() {
            const [images, setImages] = useState([]);
            const [layoutRects, setLayoutRects] = useState([]); 
            const [treeRoot, setTreeRoot] = useState(null);
            const [showTree, setShowTree] = useState(false);
            const [retryCount, setRetryCount] = useState(0);

            const [selectedSize, setSelectedSize] = useState('A4');
            const [selectedImageId, setSelectedImageId] = useState(null);
            const [isGenerating, setIsGenerating] = useState(false);
            const [isSaving, setIsSaving] = useState(false);
            const [zoom, setZoom] = useState(1);
            const [selectedIteration, setSelectedIteration] = useState(0);
            
            const [gapSize, setGapSize] = useState(1);
            const [selectedDpi, setSelectedDpi] = useState(600);
            
            const isDragging = useRef(false);
            const startPos = useRef({ x: 0, y: 0 });
            const initialOffset = useRef({ x: 0.5, y: 0.5 }); 
            const isMoved = useRef(false);
            const activeId = useRef(null);

            useEffect(() => {
                if (images.length > 0) regenerateLayout(images, false);
            }, [selectedSize]);

            const regenerateLayout = (currentImages, doShuffle = true) => {
                if (currentImages.length === 0) {
                    setLayoutRects([]); setTreeRoot(null); return;
                }
                setIsGenerating(true);
                setRetryCount(0);
                
                setTimeout(() => {
                    const sizeConfig = PAPER_SIZES[selectedSize];
                    const imagesMap = new Map(currentImages.map(img => [img.id, img]));
                    let ids = currentImages.map(img => img.id);
                    if (doShuffle) ids = ids.sort(() => Math.random() - 0.5);

                    let bestRects = null;
                    let bestRoot = null;
                    let minMismatches = Infinity;
                    let minBadTiles = Infinity;
                    let bestIter = 0;

                    for(let i=0; i<MAX_ITERATIONS; i++) {
                        setRetryCount(i + 1);
                        if(i > 0) ids = ids.sort(() => Math.random() - 0.5);

                        const result = calculateAdaptiveLayout(ids, imagesMap, sizeConfig.width, sizeConfig.height);
                        
                        let mismatches = 0;
                        let badTiles = 0;

                        result.rects.forEach(r => {
                            const img = imagesMap.get(r.imageId);
                            const slotAspect = r.w / r.h;
                            
                            // Check 1: Orientation
                            const imgIsLand = img.aspect >= 1.0;
                            const slotIsLand = slotAspect >= 1.0;
                            if (imgIsLand !== slotIsLand) mismatches++;

                            // Check 2: Bad Tiles (Strict)
                            // üí° Stricter bad tile threshold
                            if (slotAspect > 1.8 || slotAspect < 0.55) badTiles++;
                        });

                        // Selection Logic
                        if (bestRects === null) {
                            bestRects = result.rects; bestRoot = result.root;
                            minMismatches = mismatches; minBadTiles = badTiles;
                            bestIter = i + 1;
                        } else {
                            if (mismatches < minMismatches) {
                                minMismatches = mismatches; minBadTiles = badTiles;
                                bestRects = result.rects; bestRoot = result.root;
                                bestIter = i + 1;
                            } else if (mismatches === minMismatches) {
                                if (badTiles < minBadTiles) {
                                    minBadTiles = badTiles;
                                    bestRects = result.rects; bestRoot = result.root;
                                    bestIter = i + 1;
                                }
                            }
                        }

                        // Perfect Match Condition
                        if (mismatches === 0 && badTiles === 0) {
                            break; 
                        }
                    }

                    setLayoutRects(bestRects);
                    setTreeRoot(bestRoot);
                    setSelectedIteration(bestIter);
                    setIsGenerating(false);
                    setZoom(1); 
                }, 100);
            };

            const performSwap = (id1, id2) => {
                if (!treeRoot) return;
                const nodeA = findNodeByImageId(treeRoot, id1);
                const nodeB = findNodeByImageId(treeRoot, id2);
                if (nodeA && nodeB) {
                    const temp = nodeA.imageId;
                    nodeA.imageId = nodeB.imageId;
                    nodeB.imageId = temp;
                    const sizeConfig = PAPER_SIZES[selectedSize];
                    const imagesMap = new Map(images.map(img => [img.id, img]));
                    const newRects = flattenTree(treeRoot, 0, 0, sizeConfig.width, sizeConfig.height, imagesMap);
                    setLayoutRects(newRects);
                    setTreeRoot({...treeRoot});
                }
            };

            const handleFileUpload = async (e) => { if (!e.target.files.length) return; setIsGenerating(true); const files = Array.from(e.target.files); const newImages = await Promise.all(files.map(file => loadImageMeta(file))); setImages(prev => { const updated = [...prev, ...newImages]; setTimeout(() => regenerateLayout(updated, false), 100); return updated; }); e.target.value = ''; };
            const handlePointerDown = (e, id) => { e.stopPropagation(); isDragging.current = true; isMoved.current = false; activeId.current = id; const cX = e.touches ? e.touches[0].clientX : e.clientX; const cY = e.touches ? e.touches[0].clientY : e.clientY; startPos.current = { x: cX, y: cY }; const img = images.find(i => i.id === id); if (img) initialOffset.current = { x: img.offsetX, y: img.offsetY }; };
            const handlePointerMove = (e) => { if (!isDragging.current) return; e.preventDefault(); const cX = e.touches ? e.touches[0].clientX : e.clientX; const cY = e.touches ? e.touches[0].clientY : e.clientY; const dX = cX - startPos.current.x; const dY = cY - startPos.current.y; if (!isMoved.current && (Math.abs(dX) > 5 || Math.abs(dY) > 5)) { isMoved.current = true; setSelectedImageId(activeId.current); } if (isMoved.current) { const sens = 0.002 / zoom; const nX = initialOffset.current.x - dX * sens; const nY = initialOffset.current.y - dY * sens; setImages(prev => prev.map(img => img.id === activeId.current ? { ...img, offsetX: Math.max(0, Math.min(1, nX)), offsetY: Math.max(0, Math.min(1, nY)) } : img)); } };
            const handlePointerUp = (e) => { if (!isDragging.current) return; isDragging.current = false; e.stopPropagation(); if (!isMoved.current && activeId.current) { const clickedId = activeId.current; if (selectedImageId === null) setSelectedImageId(clickedId); else if (selectedImageId === clickedId) setSelectedImageId(null); else { performSwap(selectedImageId, clickedId); setSelectedImageId(null); } } activeId.current = null; };
            const handleDeleteImage = (e, id) => { e.stopPropagation(); setImages(prev => { const next = prev.filter(img => img.id !== id); if (selectedImageId === id) setSelectedImageId(null); setTimeout(() => regenerateLayout(next, false), 100); return next; }); };
            
            const handleDownload = async () => { 
                if (layoutRects.length === 0 || images.length === 0) return; 
                if (isSaving) return; 
                setIsSaving(true); 
                
                await new Promise(r => setTimeout(r, 50)); 
                
                const processDownload = async () => { 
                    const scaleFactor = selectedDpi / 600;
                    const sizeConfig = PAPER_SIZES[selectedSize]; 
                    const finalW = sizeConfig.width * scaleFactor; 
                    const finalH = sizeConfig.height * scaleFactor; 
                    
                    let canvas = document.createElement('canvas'); 
                    canvas.width = finalW; 
                    canvas.height = finalH; 
                    const ctx = canvas.getContext('2d'); 
                    ctx.fillStyle = '#ffffff'; 
                    ctx.fillRect(0, 0, finalW, finalH); 
                    
                    const actualGap = (gapSize * (finalW / 800)) * 0.5; 
                    
                    const promises = layoutRects.map(rect => { 
                        const imgData = images.find(img => img.id === rect.imageId); 
                        if (!imgData) return Promise.resolve(); 
                        return new Promise((resolve) => { 
                            const img = new window.Image(); 
                            img.crossOrigin = "anonymous"; 
                            img.onload = () => { 
                                const dX = rect.x * scaleFactor + actualGap; 
                                const dY = rect.y * scaleFactor + actualGap; 
                                const dW = rect.w * scaleFactor - actualGap * 2; 
                                const dH = rect.h * scaleFactor - actualGap * 2; 
                                if (dW > 0 && dH > 0) { 
                                    const iRatio = img.width / img.height; 
                                    const bRatio = dW / dH; 
                                    let sX, sY, sW, sH; 
                                    if (iRatio > bRatio) { 
                                        sH = img.height; 
                                        sW = img.height * bRatio; 
                                        sX = (img.width - sW) * imgData.offsetX; 
                                        sY = 0; 
                                    } else { 
                                        sW = img.width; 
                                        sH = img.width / bRatio; 
                                        sX = 0; 
                                        sY = (img.height - sH) * imgData.offsetY; 
                                    } 
                                    ctx.save(); 
                                    ctx.beginPath(); 
                                    ctx.rect(dX, dY, dW, dH); 
                                    ctx.clip(); 
                                    ctx.imageSmoothingQuality = 'high'; 
                                    ctx.drawImage(img, sX, sY, sW, sH, dX, dY, dW, dH); 
                                    ctx.restore(); 
                                } 
                                resolve(); 
                            }; 
                            img.src = imgData.url; 
                        }); 
                    }); 
                    
                    await Promise.all(promises); 
                    
                    const link = document.createElement('a'); 
                    const dateStr = formatDate();
                    link.download = `SmartCollage_${selectedSize}_${selectedDpi}DPI_${dateStr}.jpg`; 
                    
                    link.href = canvas.toDataURL('image/jpeg', 0.95); 
                    link.click(); 
                    canvas.width = 1; canvas.height = 1; 
                    link.remove(); 
                }; 
                
                try { 
                    await processDownload(); 
                } catch (err) { 
                    alert("Ï†ÄÏû• Ïã§Ìå®: Î©îÎ™®Î¶¨ Î∂ÄÏ°± Í∞ÄÎä•ÏÑ±"); 
                } finally { 
                    setIsSaving(false); 
                } 
            };
            const handleZoom = (d) => setZoom(prev => Math.max(0.5, Math.min(4, prev + d)));

            const currentConfig = PAPER_SIZES[selectedSize];

            return (
                <div className="flex flex-col h-full w-full bg-white text-gray-800 font-sans overflow-hidden"
                    onPointerUp={handlePointerUp} onPointerMove={handlePointerMove} onTouchEnd={handlePointerUp} onTouchMove={handlePointerMove}>
                    
                    <header className="flex items-center justify-between px-4 py-3 bg-white shadow-sm shrink-0 z-30 border-b border-gray-100">
                        <div className="flex items-center gap-2">
                            <div className="bg-indigo-600 text-white p-1.5 rounded-lg"><IconMonitor size={20} /></div>
                            <h1 className="text-lg font-bold text-gray-900">Smart Collage</h1>
                        </div>
                        <div className="flex items-center gap-2">
                            <button onClick={() => setShowTree(!showTree)} className={`flex items-center gap-1 px-3 py-1.5 rounded-full text-xs font-medium transition-colors border ${showTree ? 'bg-indigo-50 text-indigo-600 border-indigo-200' : 'bg-white text-gray-500 border-gray-200'}`}>
                                <IconTree size={16}/> <span>Íµ¨Ï°∞</span>
                            </button>
                            <label className="flex items-center justify-center w-10 h-10 bg-indigo-50 text-indigo-600 rounded-full cursor-pointer hover:bg-indigo-100 relative transition-colors">
                                <IconUpload size={20} />
                                <input type="file" multiple accept="image/*" className="hidden" onChange={handleFileUpload} />
                            </label>
                            <button onClick={handleDownload} disabled={images.length===0 || isSaving} className={`flex items-center justify-center w-10 h-10 rounded-full font-medium transition-colors ${images.length===0?'bg-gray-100 text-gray-400':'bg-green-600 hover:bg-green-700 text-white shadow-sm'}`}>
                                {isSaving ? <span className="animate-spin text-xs">‚è≥</span> : <IconDownload size={20} />}
                            </button>
                        </div>
                    </header>

                    <div className="bg-white border-b border-gray-100 shrink-0 h-20 flex items-center gap-3 overflow-x-auto px-4 py-2 no-scrollbar">
                        {images.length === 0 && <span className="text-xs text-gray-400 mx-auto">ÏÇ¨ÏßÑ Ï∂îÍ∞Ä ÌïÑÏöî</span>}
                        {images.map(img => {
                            const isLandscape = img.aspect >= 1;
                            const containerClass = isLandscape 
                                ? "relative w-24 h-16 shrink-0 rounded-md overflow-hidden border border-gray-200 shadow-sm"
                                : "relative w-10 h-16 shrink-0 rounded-md overflow-hidden border border-gray-200 shadow-sm";

                            return (
                                <div key={img.id} className={containerClass} style={{ WebkitTouchCallout: 'none' }}>
                                    <img src={img.url} className="w-full h-full object-cover pointer-events-none" style={{ WebkitTouchCallout: 'none' }} />
                                    <button onClick={(e) => handleDeleteImage(e, img.id)} className="absolute top-0 right-0 bg-black/50 text-white p-0.5"><IconX size={10} /></button>
                                </div>
                            );
                        })}
                    </div>

                    {/* üí° OPTIONS BAR (Gap & DPI) */}
                    <div className="bg-gray-50 border-b border-gray-200 shrink-0 py-2 px-4 flex items-center justify-between gap-4 z-20 text-xs text-gray-600">
                        <div className="flex items-center gap-3 flex-1">
                            <div className="flex items-center gap-2 bg-white px-2 py-1 rounded border border-gray-200 shadow-sm">
                                <span className="font-semibold text-gray-500 whitespace-nowrap">Í∞ÑÍ≤©</span>
                                {/* Gap Slider 1-3 */}
                                <input 
                                    type="range" 
                                    min="1" 
                                    max="3" 
                                    step="1" 
                                    value={gapSize} 
                                    onChange={(e) => setGapSize(Number(e.target.value))}
                                    className="w-16 h-1 bg-gray-200 rounded-lg appearance-none cursor-pointer"
                                />
                                <span className="w-6 text-right font-medium">{gapSize}px</span>
                            </div>

                            <div className="flex items-center gap-1 bg-white px-2 py-1 rounded border border-gray-200 shadow-sm">
                                <span className="font-semibold text-gray-500 whitespace-nowrap">Ìï¥ÏÉÅÎèÑ</span>
                                <select 
                                    value={selectedDpi} 
                                    onChange={(e) => setSelectedDpi(Number(e.target.value))}
                                    className="bg-transparent font-medium text-gray-800 outline-none cursor-pointer"
                                >
                                    {DPI_OPTIONS.map(dpi => (
                                        <option key={dpi} value={dpi}>{dpi} DPI</option>
                                    ))}
                                </select>
                            </div>
                        </div>
                    </div>

                    <div className="bg-white border-b border-gray-100 shrink-0 py-2 px-4 flex items-center justify-between gap-4 z-20">
                        <div className="flex-1 overflow-x-auto no-scrollbar flex items-center gap-2">
                            {Object.entries(PAPER_SIZES).map(([key, config]) => (
                                <button key={key} onClick={() => setSelectedSize(key)} className={`whitespace-nowrap px-3 py-1.5 text-xs rounded-full border transition-all ${selectedSize===key?'bg-indigo-600 text-white':'bg-white text-gray-500'}`}>{config.name}</button>
                            ))}
                        </div>
                        <button onClick={() => regenerateLayout(images, true)} className="bg-indigo-50 text-indigo-600 p-2 rounded-full hover:bg-indigo-100">
                             <IconRefresh size={16} className={isGenerating ? 'animate-spin' : ''} />
                        </button>
                    </div>

                    <main className="flex-1 relative overflow-hidden bg-white flex flex-col items-center justify-start pt-24 p-4">
                        {images.length > 0 ? (
                            <div className="transition-transform duration-200 ease-out origin-top" style={{ transform: `scale(${zoom})`, width: '100%', height: 'auto', display: 'flex', justifyContent: 'center' }}>
                                <div className={`bg-white shadow-2xl relative transition-all duration-300 ${isGenerating ? 'evolution-active' : ''}`}
                                    style={{ aspectRatio: `${currentConfig.ratio}`, width: '100%', maxWidth: '600px' }}>
                                    
                                    {/* Image Layer */}
                                    <div className="absolute inset-0 w-full h-full">
                                        {layoutRects.map(rect => {
                                            const imgData = images.find(i => i.id === rect.imageId);
                                            if (!imgData) return null;
                                            const isSelected = selectedImageId === rect.imageId;
                                            
                                            // Ratio Check
                                            const tileAspect = rect.w / rect.h;
                                            const isSacrificed = (imgData.aspect >= 1.0 && tileAspect < 1.0) || (imgData.aspect < 1.0 && tileAspect >= 1.0);
                                            const isExtreme = tileAspect > 2.0 || tileAspect < 0.5;

                                            return (
                                                <div key={rect.imageId} className="absolute tile-transition"
                                                    style={{
                                                        left: `${(rect.x / currentConfig.width)*100}%`, top: `${(rect.y / currentConfig.height)*100}%`,
                                                        width: `${(rect.w / currentConfig.width)*100}%`, height: `${(rect.h / currentConfig.height)*100}%`,
                                                        padding: `${gapSize/2}px`
                                                    }}>
                                                    <div className={`w-full h-full relative group overflow-hidden bg-gray-100 cursor-pointer ${isSelected ? 'selected-tile' : ''} ${isExtreme ? 'border-2 border-red-500' : ''}`}
                                                         onPointerDown={(e) => handlePointerDown(e, rect.imageId)}>
                                                        <img src={imgData.url} className="w-full h-full object-cover pointer-events-none select-none" style={{objectPosition: `${imgData.offsetX*100}% ${imgData.offsetY*100}%`}} />
                                                        {isSelected && <div className="absolute top-2 left-2 bg-indigo-600 text-white text-[10px] px-2 py-1 rounded-full shadow"><IconHand size={10}/> <span>ÏÑ†ÌÉùÎê®</span></div>}
                                                        {(isSacrificed || isExtreme) && <div className="absolute top-2 right-2 bg-red-500/90 text-white p-1 rounded-full shadow-md" title="ÎπÑÏú® Î∂àÏùºÏπò"><IconScissors size={12} /></div>}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                    {showTree && treeRoot && <TreeOverlay node={treeRoot} totalW={currentConfig.width} totalH={currentConfig.height} />}
                                </div>
                            </div>
                        ) : (
                            <div className="mt-20 text-center text-gray-400 text-sm"><p>ÏÇ¨ÏßÑÏùÑ Ï∂îÍ∞ÄÌïòÏÑ∏Ïöî</p></div>
                        )}
                        
                        {isGenerating && (
                             <div className="absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 z-50 bg-white/90 px-6 py-4 rounded-lg shadow-xl text-center">
                                 <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-indigo-600 mx-auto mb-2"></div>
                                 <p className="text-sm font-medium text-gray-700">ÏµúÏ†Å ÎπÑÏú® Ï∞æÎäî Ï§ë...</p>
                                 <p className="text-xs text-gray-500 mt-1">ÏãúÎèÑ: {retryCount} / {MAX_ITERATIONS}</p>
                             </div>
                        )}

                        {images.length > 0 && (
                            <>
                                <div className="absolute top-4 left-1/2 -translate-x-1/2 flex gap-4 bg-white/90 px-4 py-2 rounded-full shadow-lg border border-gray-200 z-40">
                                    <button onClick={() => handleZoom(-0.1)}><IconZoomOut size={20}/></button>
                                    <span className="text-xs w-8 text-center">{Math.round(zoom*100)}%</span>
                                    <button onClick={() => handleZoom(0.1)}><IconZoomIn size={20}/></button>
                                </div>
                                <div className="absolute top-16 left-1/2 -translate-x-1/2 bg-black/50 text-white px-3 py-1 rounded-full text-[10px] backdrop-blur-sm z-30 pointer-events-none">
                                    Selected Try: #{selectedIteration}
                                </div>
                            </>
                        )}
                    </main>
                </div>
            );
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>

